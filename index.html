<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>顔姿勢検知と自動撮影アプリ</title>
    <!-- MediaPipe Face Mesh -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 100%;
            padding: 20px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .video-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin-bottom: 20px;
        }
        #input-video {
            width: 100%;
            border-radius: 8px;
            background-color: #000;
        }
        #output-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        .countdown {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
        }
        /* カウントダウン表示のスタイル変更 */
        .countdown-large {
            font-size: 48px;
            font-weight: bold;
            color: white;
            background-color: black;
            padding: 10px 30px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            width: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .status-panel {
            width: 100%;
            max-width: 640px;
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status-text {
            font-size: 18px;
            text-align: center;
            margin-bottom: 10px;
        }
        .pose-info {
            font-size: 14px;
            text-align: center;
            margin-bottom: 10px;
        }
        .threshold-controls {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .threshold-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .threshold-control label {
            flex: 1;
        }
        .threshold-control input {
            flex: 2;
        }
        .threshold-control span {
            flex: 0.5;
            text-align: right;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            background-color: #0066cc;
            color: white;
            font-size: 16px;
            cursor: pointer;
            min-width: 140px;
        }
        button:disabled {
            background-color: #cccccc;
        }
        button:hover:not(:disabled) {
            background-color: #0055aa;
        }
        .mode-button {
            background-color: #4CAF50;
        }
        .mode-button:hover:not(:disabled) {
            background-color: #3e8e41;
        }
        .capture-button {
            background-color: #f44336;
        }
        .capture-button:hover:not(:disabled) {
            background-color: #d32f2f;
        }
        .gallery {
            width: 100%;
            max-width: 640px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .gallery-item {
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .gallery-item h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }
        .captures-grid {
            display: block; /* グリッドからブロックに変更 */
            max-width: 100%;
            margin: 0 auto;
        }
        .capture-item {
            position: relative;
            border: 2px solid #f44336; /* デフォルトで赤枠を表示 */
            border-radius: 4px;
            padding: 5px;
            margin: 0 auto;
            max-width: 300px; /* 幅を制限 */
        }
        .capture-item.best {
            border: 3px solid #f44336;
        }
        .capture-image {
            width: 100%;
            border-radius: 2px;
        }
        .capture-info {
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
        }
        .recorded-video {
            width: 100%;
            border-radius: 4px;
        }
        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.1s;
        }
        .email-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 2000;
            width: 400px; /* 幅を広げる */
            max-height: 80vh; /* 画面の80%までの高さに制限 */
            overflow-y: auto; /* 縦スクロールを有効に */
        }

        .email-dialog input[type="email"] {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .privacy-policy-container {
            margin-top: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .privacy-policy-content {
            height: 200px; /* 固定高さ */
            overflow-y: auto;
            padding: 10px;
            font-size: 12px;
            background-color: #f9f9f9;
        }

        .privacy-policy-content h2 {
            font-size: 14px;
            margin-top: 0;
        }

        .privacy-policy-content h3 {
            font-size: 13px;
            margin-top: 10px;
            margin-bottom: 5px;
        }

        .privacy-policy-content p {
            margin: 8px 0;
        }

        .privacy-checkbox {
            margin: 15px 0;
            display: flex;
            align-items: center;
        }

        .privacy-checkbox input {
            margin-right: 8px;
        }

        .email-display {
            background-color: #f0f0f0;
            padding: 5px 10px;
            border-radius: 4px;
            margin-top: 5px;
            font-size: 14px;
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            cursor: pointer;
            border: 1px solid #ddd;
        }

        .email-display:hover {
            background-color: #e6e6e6;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1999;
        }
        .small-button {
            font-size: 12px;
            padding: 5px 10px;
            min-width: 100px;
            background-color: #888;
        }
        .small-button:hover:not(:disabled) {
            background-color: #666;
        }
        .small-button.active {
            background-color: #4CAF50;
        }

        .threshold-panel {
            display: none; /* デフォルトは非表示 */
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .side-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 2000;
            width: 90%;
            max-width: 500px;
            text-align: center;
        }

        .side-image {
            width: 100%;
            max-width: 400px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .side-question {
            font-size: 18px;
            margin-bottom: 20px;
        }

        .side-buttons {
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }

        .side-button {
            flex: 1;
            padding: 12px;
            border-radius: 30px;
            border: 2px solid #888;
            background-color: white;
            color: #333;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .side-button:hover {
            background-color: #f0f0f0;
        }
         /* 送信中ダイアログのスタイル */
         @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 2000;
        }
        
        .dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 2001;
            text-align: center;
            min-width: 300px;
        }
        
        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin: 0 auto 15px auto;
        }
        
        .status-text {
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .progress-text {
            font-size: 14px;
            color: #666;
        }
        
        .success-icon {
            font-size: 48px;
            color: #4CAF50;
            margin-bottom: 15px;
        }
        
        .error-icon {
            font-size: 48px;
            color: #f44336;
            margin-bottom: 15px;
        }
        
        .message-text {
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .detail-text {
            margin-bottom: 15px;
            font-size: 14px;
            color: #666;
        }
        
        .ok-button {
            padding: 8px 30px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .success-button {
            background-color: #4CAF50;
        }
        
        .error-button {
            background-color: #f44336;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="email-overlay" class="overlay" style="display: none;"></div>
        <div id="email-dialog" class="email-dialog" style="display: none;">
            <h3>Entrez votre adresse e-mail</h3>
            <p>L'enregistrement de votre adresse e-mail est nécessaire pour sauvegarder et télécharger les données.<br>
            Email required to save and download data.</p>
            <input type="email" id="email-input" placeholder="例: example@example.com">
            <div class="privacy-policy-container">
                <h2>Politique de confidentialité</h2>
                <div class="privacy-policy-content">
                    <h2>Politique de confidentialité (Formulaire d'envoi de photo du visage)</h2>
                    <h3>Face Matrix Academia Co., Ltd. (ci-après « notre société ») traite les données personnelles obtenues dans le cadre du concours de techniques esthétiques qu'elle organise, conformément à la politique suivante.</h3>
                    <h3>1. Données personnelles collectées</h3>
                    <p>Actuellement, les informations collectées via ce formulaire sont les suivantes :<br>
                    - Adresse e-mail<br>
                    - Photographies du visage (avant/après traitement)</p>
                    <p>À l'avenir, en fonction de l'évolution du service, nous pourrions également collecter les informations suivantes :<br>
                    - Nom complet<br>
                    - Sexe<br>
                    - Préoccupations concernant la peau ou le visage</p>
                    <h3>2. Finalités d'utilisation</h3>
                    <p>Les données personnelles fournies seront utilisées aux fins suivantes :<br>
                    - Communication, gestion administrative et opérationnelle liée au concours<br>
                    - Évaluation des effets des soins réalisés par les technicien·ne·s<br>
                    - Développement de nouveaux produits et amélioration des services existants basés sur les données visuelles<br>
                    - Recherche et amélioration des algorithmes d'analyse faciale et des critères de mesure<br>
                    - Réalisation d'analyses et évaluations à partir des photographies du visage, avec envoi du rapport à l'adresse e-mail fournie<br>
                    - Partage, dans les limites nécessaires, avec les sociétés affiliées, les sous-traitants ou les partenaires commerciaux<br>
                    　※ Notre société conclut des accords contractuels pour garantir un traitement approprié de ces données et exerce une supervision adéquate.</p>
                    <h3>3. Partage avec des tiers</h3>
                    <p>Nous ne fournirons les données personnelles à des tiers que dans les cas suivants :<br>
                    - Consentement explicite de la personne concernée<br>
                    - Obligation légale<br>
                    - Partage nécessaire avec les sociétés affiliées, sous-traitants (tels que prestataires de services cloud) ou partenaires, dans le cadre des finalités ci-dessus<br>
                    - Fourniture de données anonymisées sous forme statistique</p>
                    <h3>4. Durée de conservation et mesures de sécurité</h3>
                    <p>- Les données personnelles seront supprimées ou rendues anonymes dans les 90 jours suivant la fin du concours.<br>
                    - Les données sont actuellement stockées sur un serveur situé en France, au sein de l'Espace économique européen (EEE), et sont gérées conformément au Règlement général sur la protection des données (RGPD).<br>
                    - Nous garantissons aux personnes résidant dans l'EEE les droits prévus par le RGPD, y compris les droits d'accès, de rectification, de suppression, de limitation du traitement, de portabilité des données et de retrait du consentement.<br>
                    - Nous mettons en œuvre des mesures techniques et organisationnelles appropriées et respectons la loi japonaise sur la protection des informations personnelles ainsi que les règles complémentaires convenues entre le Japon et l'UE.</p>
                    <h3>5. Droits des personnes concernées (conformément au RGPD)</h3>
                    <p>Conformément aux articles 15 à 21 du RGPD, vous disposez des droits suivants :<br>
                    - Droit d'accès à vos données personnelles<br>
                    - Droit de rectification de données inexactes<br>
                    - Droit à l'effacement (« droit à l'oubli »)<br>
                    - Droit à la limitation du traitement<br>
                    - Droit d'opposition au traitement<br>
                    - Droit de retrait du consentement (le traitement antérieur au retrait reste licite)</p>
                    <p>Pour exercer ces droits, veuillez nous contacter via les coordonnées ci-dessous.</p>
                    <h3>6. Contact</h3>
                    <p>Face Matrix Academia Co., Ltd.<br>
                    Responsable : Yuji Kuroda<br>
                    Adresse e-mail : info@viewtech.co.jp</p>
                    <p>Cette politique de confidentialité est susceptible d'être modifiée sans préavis. Veuillez consulter cette page pour toute mise à jour.</p>
                </div>
            </div>
            <div class="privacy-checkbox">
                <input type="checkbox" id="privacy-agree" required>
                <label for="privacy-agree">J'accepte la politique de confidentialité</label>
            </div>
            <button id="email-submit" style="background-color: #4CAF50; width: 100%;" disabled>OK</button>
        </div>
        <div id="email-display" class="email-display" style="display: none;"></div>

        <!-- <h1>顔姿勢検知と自動撮影アプリ</h1> --> <!-- アプリ名を削除 -->
    
        <!-- カウントダウン表示を大きく配置 -->
        <div id="countdown" class="countdown-large" style="display: none;">5:00</div>
        
        <div class="video-container">
            <video id="input-video" autoplay playsinline></video>
            <canvas id="output-canvas"></canvas>
        </div>
        
        <div class="status-panel">
            <div class="status-text" id="status-text">Tap "1. Start 'Before' Photo" to begin.</div>
            <div class="pose-info" id="pose-info"></div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div id="threshold-panel" class="threshold-panel">
                <div class="threshold-controls">
                    <!-- スライダー要素 -->
                    <div class="threshold-controls">
                        <div class="threshold-control">
                            <label for="roll-threshold">Tolérance roulis:</label>
                            <input type="range" id="roll-threshold" min="0" max="5" value="3.0" step="0.5">
                            <span id="roll-threshold-value">3.0°</span>
                        </div>
                        <div class="threshold-control">
                            <label for="pitch-threshold">Tolérance tangage:</label>
                            <input type="range" id="pitch-threshold" min="0" max="8" value="8.0" step="0.5">
                            <span id="pitch-threshold-value">8.0°</span>
                        </div>
                        <div class="threshold-control">
                            <label for="yaw-threshold">Tolérance lacet:</label>
                            <input type="range" id="yaw-threshold" min="0" max="5" value="3.0" step="0.5">
                            <span id="yaw-threshold-value">3.0°</span>
                        </div>
                        <div class="threshold-control">
                            <label for="stability-time">Temps de stabilité:</label>
                            <input type="range" id="stability-time" min="0.1" max="1.0" value="0.5" step="0.1">
                            <span id="stability-time-value">0.5</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button id="start-btn" class="mode-button">1. Start "Before" Photo</button>
            <button id="preview-btn" class="mode-button" disabled>2. Start 5-Min Challenge</button>
            <!-- <button id="switch-camera-btn" disabled>カメラ切替</button>  -->
            <!-- <button id="manual-capture-btn" class="capture-button" disabled>手動キャプチャ</button> -->
            <button id="toggle-mesh-btn" class="small-button">メッシュ表示</button>
            <button id="toggle-settings-btn" class="small-button">設定表示</button>
        </div>
        
        <div class="gallery">
            <div class="gallery-item" id="before-captures" style="display: none;">
                <h3>Photos "avant"</h3>
                <div class="captures-grid" id="before-grid"></div>
            </div>
            
            <div class="gallery-item" id="video-capture" style="display: none;">
                <h3>Enregistrement vidéo</h3>
                <video id="recorded-video" class="recorded-video" controls></video>
                <a id="download-link" href="#" download="recorded-video.webm" style="display: block; margin-top: 10px;">ダウンロード</a>
            </div>
            
            <div class="gallery-item" id="after-captures" style="display: none;">
                <h3>Photos "après"</h3>
                <div class="captures-grid" id="after-grid"></div>
            </div>
        </div>
    </div>

    <!-- 施術部位選択ダイアログ -->
    <div id="side-dialog-overlay" class="overlay" style="display: none;"></div>
    <div id="side-dialog" class="side-dialog" style="display: none;">
        <div class="side-dialog-content">
            <img id="side-dialog-image" class="side-image" src="" alt="施術後の画像">
            <p class="side-question">Le traitement a-t-il été effectué sur le côté droit ou gauche de votre visage ?</p>
            <div class="side-buttons">
                <button id="right-side-btn" class="side-button">←Côté droit</button>
                <button id="left-side-btn" class="side-button">Côté gauche→</button>
            </div>
        </div>
    </div>

    <!-- 送信中ダイアログ用HTML -->
    <div id="sending-overlay" class="overlay" style="display: none;">
    </div>
    <div id="sending-dialog" class="dialog" style="display: none;">
        <div class="spinner"></div>
        <div id="sending-status" class="status-text">Envoi de données en cours...</div>
        <div id="sending-progress" class="progress-text">Préparation...</div>
    </div>
    
    <!-- 成功ダイアログ用HTML -->
    <div id="success-overlay" class="overlay" style="display: none;">
    </div>
    <div id="success-dialog" class="dialog" style="display: none;">
        <div class="success-icon">✓</div>
        <div class="message-text">Données envoyées avec succès!</div>
        <button id="success-ok" class="ok-button success-button">OK</button>
    </div>
    
    <!-- エラーダイアログ用HTML -->
    <div id="error-overlay" class="overlay" style="display: none;">
    </div>
    <div id="error-dialog" class="dialog" style="display: none;">
        <div class="error-icon">✗</div>
        <div class="message-text">Erreur lors de l'envoi des données</div>
        <div id="error-details" class="detail-text">Veuillez réessayer plus tard.</div>
        <button id="error-ok" class="ok-button error-button">OK</button>
    </div>

    <script>
        // モード定義
        const MODE = {
            IDLE: 'idle',
            BEFORE: 'before',
            BEFORE_COMPLETED: 'before_completed',
            RECORDING: 'recording',
            AFTER: 'after',
            AFTER_COMPLETED: 'after_completed',
            COMPLETED: 'completed'
        };

        // DOM要素
        const inputVideo = document.getElementById('input-video');
        const outputCanvas = document.getElementById('output-canvas');
        const countdownEl = document.getElementById('countdown');
        const statusText = document.getElementById('status-text');
        const poseInfo = document.getElementById('pose-info');
        const progressFill = document.getElementById('progress-fill');
        const startBtn = document.getElementById('start-btn');
        const previewBtn = document.getElementById('preview-btn');
        //const switchCameraBtn = document.getElementById('switch-camera-btn');
        //const manualCaptureBtn = document.getElementById('manual-capture-btn');
        const beforeCaptures = document.getElementById('before-captures');
        const beforeGrid = document.getElementById('before-grid');
        const videoCapture = document.getElementById('video-capture');
        const recordedVideo = document.getElementById('recorded-video');
        const downloadLink = document.getElementById('download-link');
        const afterCaptures = document.getElementById('after-captures');
        const afterGrid = document.getElementById('after-grid');

        // スライダー要素
        const rollThreshold = document.getElementById('roll-threshold');
        const pitchThreshold = document.getElementById('pitch-threshold');
        const yawThreshold = document.getElementById('yaw-threshold');
        const stabilityTime = document.getElementById('stability-time');
        const rollThresholdValue = document.getElementById('roll-threshold-value');
        const pitchThresholdValue = document.getElementById('pitch-threshold-value');
        const yawThresholdValue = document.getElementById('yaw-threshold-value');
        const stabilityTimeValue = document.getElementById('stability-time-value');

        // グローバル変数
        let currentMode = MODE.IDLE;
        let camera;
        let faceMesh;
        let canvasCtx;
        let stream;
        let mediaRecorder;
        let recordedChunks = [];
        let isFrontCamera = true;
        let faceDetected = false;
        let facePose = { roll: 0, pitch: 0, yaw: 0 };
        let stableStartTime = null;
        let stablePosition = false;
        let beforeCapturesCount = 0;
        let afterCapturesCount = 0;
        let beforeCapturesList = [];
        let afterCapturesList = [];
        let countdownInterval = null;
        let countdownTimeLeft = 5 * 60; // 5分（秒単位）
        // メール関連の変数
        let userEmail = '';
        // メッシュ表示フラグ - デフォルトは非表示
        let showMesh = false;
        // 設定表示フラグ - デフォルトは非表示
        let showSettings = false; 
        // 青軸表示フラグ - デフォルトは表示  
        let showAxis = true;  
        // 施術部位情報
        let treatedSide = ''; // 'left' または 'right'
        // グローバル変数に輪郭表示フラグを追加
        let showFaceOutline = true; // デフォルトでは表示する
        let recordingStarted = false; // 録画が始まったかどうかのフラグ
        let recordingNotification = null; // 録画開始通知用の要素

        // グローバル変数に追加または修正
        // デバッグ用の短い時間と本番用の時間を両方定義
        const DEBUG_TOTAL_TIME = 70; // デバッグ用：70秒
        const PRODUCTION_TOTAL_TIME = 5 * 60; // 本番用：5分（300秒）

        // 現在使用する時間（デバッグ中はDEBUG_TOTAL_TIMEを使用）
        const TOTAL_COUNTDOWN_TIME = DEBUG_TOTAL_TIME; // デバッグ時はこの行を使用
        // const TOTAL_COUNTDOWN_TIME = PRODUCTION_TOTAL_TIME; // 本番時はこの行のコメントを外す

        // 録画開始タイミング（全体の時間から録画時間を引いた値）
        const RECORDING_START_TIME = 60; // 録画時間は1分（60秒）固定
        // 70秒の場合、録画開始は残り60秒の時点 = 開始後10秒
        // 5分（300秒）の場合、録画開始は残り60秒の時点 = 開始後240秒


        // グローバル変数に追加
        let apiEndpoints = {
            production: 'https://paris-api.face-matrix.com/event/report',
            developmentParis: 'https://paris-api.dev.face-matrix.com/event/report',
            developmentTokyo: 'https://dev-api.face-matrix.com/event/report'
        };

        let currentEndpoint = 'production'; //本番に変更
        let eventCode = 'EV-FR-2504-03'; // 本プログラム用
        let apiKey = 'd3cb3239c140b7960348743e5b24664d79b8638d'; // 対応するAPIキー

        // エンドポイントを切り替える関数
        function switchApiEndpoint(endpoint) {
            if (apiEndpoints[endpoint]) {
                currentEndpoint = endpoint;
                console.log('Endpoint changed to:', apiEndpoints[currentEndpoint]);
                return true;
            }
            return false;
        }

        // 送信中ダイアログの表示
        function showSendingDialog() {
            document.getElementById('sending-overlay').style.display = 'block';
            document.getElementById('sending-dialog').style.display = 'block';
            document.getElementById('sending-status').textContent = 'Envoi de données en cours...';
            document.getElementById('sending-progress').textContent = 'Préparation...';
            
            return {
                statusText: document.getElementById('sending-status'),
                progress: document.getElementById('sending-progress')
            };
        }

        // 送信中ダイアログを閉じる
        function closeSendingDialog() {
            document.getElementById('sending-overlay').style.display = 'none';
            document.getElementById('sending-dialog').style.display = 'none';
        }

        // 送信成功ダイアログの表示
        function showSuccessDialog() {
            document.getElementById('success-overlay').style.display = 'block';
            document.getElementById('success-dialog').style.display = 'block';
            
            document.getElementById('success-ok').addEventListener('click', function() {
                document.getElementById('success-overlay').style.display = 'none';
                document.getElementById('success-dialog').style.display = 'none';
            });
        }

        // エラーダイアログの表示
        function showErrorDialog(errorMessage) {
            document.getElementById('error-overlay').style.display = 'block';
            document.getElementById('error-dialog').style.display = 'block';
            document.getElementById('error-details').textContent = errorMessage || 'Veuillez réessayer plus tard.';
            
            document.getElementById('error-ok').addEventListener('click', function() {
                document.getElementById('error-overlay').style.display = 'none';
                document.getElementById('error-dialog').style.display = 'none';
            });
        }

        // 画像データをバイナリに変換する関数
        async function convertImageToBlob(dataUrl) {
            try {
                const response = await fetch(dataUrl);
                const blob = await response.blob();
                return blob;
            } catch (error) {
                console.error('Error converting image to blob:', error);
                throw error;
            }
        }

        // APIにデータを送信する関数を修正してサイズログを追加
    async function sendDataToAPI(beforeImageData, afterImageData, videoBlob) {
        // 送信中ダイアログを表示
        const { statusText, progress } = showSendingDialog();
        
        try {
            // メールアドレスが取得できなければエラー
            if (!userEmail) {
                throw new Error('Adresse e-mail non disponible');
            }
            
            progress.textContent = 'Préparation des images...';
            
            // 画像をBlobに変換
            const beforeImageBlob = await convertImageToBlob(beforeImageData);
            console.log(`ビフォー画像サイズ: ${Math.round(beforeImageBlob.size / 1024)} KB`);
            progress.textContent = 'Image "avant" prête...';
            
            const afterImageBlob = await convertImageToBlob(afterImageData);
            console.log(`アフター画像サイズ: ${Math.round(afterImageBlob.size / 1024)} KB`);
            progress.textContent = 'Image "après" prête...';
            
            // FormDataの作成
            const formData = new FormData();
            formData.append('email', userEmail);
            formData.append('side', treatedSide); // left または right
            formData.append('before_image', beforeImageBlob, 'before.jpg');
            formData.append('after_image', afterImageBlob, 'after.jpg');
            
            // let videoSize = 0;
            // if (videoBlob) {
            //     videoSize = videoBlob.size;
            //     console.log(`動画サイズ: ${Math.round(videoBlob.size / 1024 / 1024)} MB (${Math.round(videoBlob.size / 1024)} KB)`);
            //     progress.textContent = 'Préparation de la vidéo...';
            //     formData.append('movie', videoBlob, 'recording.webm');
            // }
            
            // // FormDataの総サイズを計算
            // const totalSize = beforeImageBlob.size + afterImageBlob.size + videoSize;
            // console.log(`総送信データサイズ: ${Math.round(totalSize / 1024 / 1024)} MB (${Math.round(totalSize / 1024)} KB)`);
            
            // 詳細なFormDataサイズをログ出力
            //console.log('--- 送信データ詳細 ---');
            let formDataTotalSize = 0;
            for (let [key, value] of formData.entries()) {
                if (value instanceof Blob) {
                    formDataTotalSize += value.size;
                    console.log(`${key}: ${Math.round(value.size / 1024)} KB`);
                } else {
                    console.log(`${key}: ${value}`);
                }
            }
            console.log(`FormData総サイズ（概算）: ${Math.round(formDataTotalSize / 1024 / 1024)} MB (${Math.round(formDataTotalSize / 1024)} KB)`);
            
            // ヘッダー設定
            const headers = {
                'X-Event-Code': eventCode,
                'X-Api-Auth-Key': apiKey
            };
            
            // 現在のエンドポイントを取得
            const endpoint = apiEndpoints[currentEndpoint];
            
            progress.textContent = 'Envoi des données au serveur...';
            statusText.textContent = 'Envoi en cours...';
            
            // POSTリクエスト送信
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: headers,
                body: formData
            });
            
            // レスポンスのJSONを解析
            const result = await response.json();
            
            // 送信中ダイアログを閉じる
            closeSendingDialog();
            
            // 成功・失敗の確認
            if (response.ok && result.success) {
                showSuccessDialog();
                return true;
            } else {
                throw new Error('Réponse du serveur: ' + JSON.stringify(result));
            }
        } catch (error) {
            console.error('Error sending data to API:', error);
            closeSendingDialog();
            showErrorDialog(error.message);
            return false;
        }
    }


        // 初期化
        function init() {
            canvasCtx = outputCanvas.getContext('2d');

            // メールダイアログのイベントリスナー
            document.getElementById('email-submit').addEventListener('click', saveEmail);
            // メールダイアログのイベントリスナー
            document.getElementById('email-submit').addEventListener('click', saveEmail);
            document.getElementById('privacy-agree').addEventListener('change', function() {
                document.getElementById('email-submit').disabled = !this.checked;
            });
            // 起動時にメールダイアログを表示
            showEmailDialog();
            // メール表示部分のクリックイベント追加
            document.getElementById('email-display').addEventListener('click', showEmailDialog);
            
            // スライダーイベントリスナー
            rollThreshold.addEventListener('input', updateThresholdValue);
            pitchThreshold.addEventListener('input', updateThresholdValue);
            yawThreshold.addEventListener('input', updateThresholdValue);
            stabilityTime.addEventListener('input', updateThresholdValue);
            
            // ボタンイベントリスナー
            startBtn.addEventListener('click', startProcess);
            previewBtn.addEventListener('click', startPreview);
            //switchCameraBtn.addEventListener('click', switchCamera);
            //manualCaptureBtn.addEventListener('click', manualCapture);
            
            // 施術部位選択ボタンのイベントリスナー
            document.getElementById('right-side-btn').addEventListener('click', function() {
                saveTreatedSide('right');
            });
            
            document.getElementById('left-side-btn').addEventListener('click', function() {
                saveTreatedSide('left');
            });

            // 初期値表示
            updateThresholdValue();
            
            // MediaPipe Face Mesh の初期化
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults(onResults);

            // toggleMeshボタンのイベントリスナー
            document.getElementById('toggle-mesh-btn').addEventListener('click', toggleMeshDisplay);
            // toggleSettingsボタンのイベントリスナー
            document.getElementById('toggle-settings-btn').addEventListener('click', toggleSettingsDisplay);
        }

        // メッシュ表示の切り替え
        function toggleMeshDisplay() {
            showMesh = !showMesh;
            const button = document.getElementById('toggle-mesh-btn');
            
            if (showMesh) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        }

        // 設定表示の切り替え
        function toggleSettingsDisplay() {
            showSettings = !showSettings;
            const button = document.getElementById('toggle-settings-btn');
            const panel = document.getElementById('threshold-panel');
            
            if (showSettings) {
                panel.style.display = 'block';
                button.classList.add('active');
            } else {
                panel.style.display = 'none';
                button.classList.remove('active');
            }
        }
    
        // スライダー値の更新
        function updateThresholdValue() {
            rollThresholdValue.textContent = `${parseFloat(rollThreshold.value).toFixed(1)}°`;
            pitchThresholdValue.textContent = `${parseFloat(pitchThreshold.value).toFixed(1)}°`;
            yawThresholdValue.textContent = `${parseFloat(yawThreshold.value).toFixed(1)}°`;
            stabilityTimeValue.textContent = `${parseFloat(stabilityTime.value).toFixed(1)}秒`;
        }

        // カメラ開始
        async function startCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            const constraints = {
                video: {
                    facingMode: isFrontCamera ? 'user' : 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };
            
            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                inputVideo.srcObject = stream;
                
                // キャンバスサイズの設定
                outputCanvas.width = inputVideo.videoWidth || 640;
                outputCanvas.height = inputVideo.videoHeight || 480;
                
                // MediaPipe Camera Utilsの設定
                camera = new Camera(inputVideo, {
                    onFrame: async () => {
                        await faceMesh.send({ image: inputVideo });
                    },
                    width: constraints.video.width.ideal,
                    height: constraints.video.height.ideal
                });
                
                camera.start();
                //switchCameraBtn.disabled = false;
                
                return true;
            } catch (err) {
                console.error('カメラの起動に失敗しました:', err);
                statusText.textContent = 'カメラの起動に失敗しました: ' + err.message;
                return false;
            }
        }

        // カメラ切り替え
        async function switchCamera() {
            isFrontCamera = !isFrontCamera;
            await startCamera();
        }

        // 処理開始
        async function startProcess() {
            if (currentMode === MODE.IDLE) {
                // カメラの起動
                const success = await startCamera();
                if (!success) return;
                
                // ビフォーモードに移行
                currentMode = MODE.BEFORE;
                statusText.textContent = 'Ajustez votre visage face à la caméra jusqu\'à ce que la barre sur le nez devienne un point.';
                startBtn.textContent = 'Annuler';
                previewBtn.disabled = true;
                //manualCaptureBtn.disabled = false;
                // 輪郭表示を有効にする
                showFaceOutline = true;
                
                // 準備
                beforeCapturesCount = 0;
                beforeCapturesList = [];
                beforeGrid.innerHTML = '';
                beforeCaptures.style.display = 'none';

                // ビフォーモードに移行時に状態をリセット
                progressFill.style.width = '0%';
                stableStartTime = null;
                stablePosition = false;
                
            } else if (currentMode === MODE.BEFORE || currentMode === MODE.BEFORE_COMPLETED) {
                // キャンセル処理
                resetApp();
                
            } else if (currentMode === MODE.RECORDING) {

                // 録画停止
                stopRecording();
                stopCountdown();
                hideRecordingNotification(); // 通知を非表示
                recordingStarted = false;    // 録画状態をリセット
                
                // アフターモードに移行
                currentMode = MODE.AFTER;
                statusText.textContent = 'Mode photo "après": Ajustez votre visage face à la caméra';
                startBtn.textContent = 'Annuler';
                previewBtn.disabled = true;
                //manualCaptureBtn.disabled = false;

                // 青軸を再表示
                showAxis = true;
                
                console.log('アフターモードに移行しました'); // デバッグ用

                // 準備
                afterCapturesCount = 0;
                afterCapturesList = [];
                afterGrid.innerHTML = '';
                afterCaptures.style.display = 'none';

                // アフターモードに移行時に状態をリセット
                progressFill.style.width = '0%';
                stableStartTime = null;
                stablePosition = false;
                
            } else if (currentMode === MODE.AFTER || currentMode === MODE.AFTER_COMPLETED || currentMode === MODE.COMPLETED) {
                // アフターモードでは輪郭表示を有効に
                showFaceOutline = true;
                // アプリのリセット
                resetApp();
            }
        }
        
        // プレビュー開始関数の修正（メッセージを更新）
        function startPreview() {
            if (currentMode === MODE.BEFORE_COMPLETED) {
                // 録画モードに移行
                currentMode = MODE.RECORDING;
                
                // デバッグ中かどうかでメッセージを変更
                if (TOTAL_COUNTDOWN_TIME === DEBUG_TOTAL_TIME) {
                    statusText.textContent = 'Mode vidéo: Préparation de l\'enregistrement (1 minute en fin du défi - MODE DEBUG)';
                } else {
                    statusText.textContent = 'Mode vidéo: Préparation de l\'enregistrement (1 minute en fin du défi)';
                }
                
                startBtn.textContent = 'Terminer';
                previewBtn.disabled = true;
                
                // 青軸を明示的に非表示
                showAxis = false;
                
                // カウントダウン開始
                startCountdown();
                
                // 録画はカウントダウン内で開始される
                recordingStarted = false;
            }
        }

        // カウントダウン開始関数を修正
        function startCountdown() {
            countdownTimeLeft = TOTAL_COUNTDOWN_TIME; // 設定した時間を使用
            updateCountdownDisplay();
            document.getElementById('countdown').style.display = 'flex';
            
            countdownInterval = setInterval(() => {
                countdownTimeLeft--;
                updateCountdownDisplay();
                
                // 録画開始タイミング（残り60秒になったとき）
                if (countdownTimeLeft === RECORDING_START_TIME && !recordingStarted) {
                    startRecording();
                    showRecordingNotification();
                    recordingStarted = true;
                }
                
                if (countdownTimeLeft <= 0) {
                    stopCountdown();
                    stopRecording();
                    hideRecordingNotification();
                    recordingStarted = false;
                    
                    // アフターモードに移行
                    currentMode = MODE.AFTER;
                    statusText.textContent = 'Mode photo "après": Ajustez votre visage face à la caméra (1/5)';
                    startBtn.textContent = 'Annuler';
                    previewBtn.disabled = true;
                    
                    // 青軸を再表示するために明示的に設定
                    showAxis = true;
                    
                    // 準備
                    afterCapturesCount = 0;
                    afterCapturesList = [];
                    afterGrid.innerHTML = '';
                    afterCaptures.style.display = 'none';

                    // アフターモードに移行時に状態をリセット
                    progressFill.style.width = '0%';
                    stableStartTime = null;
                    stablePosition = false;
                }
            }, 1000);
        }

        // カウントダウン停止
        function stopCountdown() {
            clearInterval(countdownInterval);
            document.getElementById('countdown').style.display = 'none';
        }

        // カウントダウン表示更新関数の修正
        function updateCountdownDisplay() {
            const minutes = Math.floor(countdownTimeLeft / 60);
            const seconds = countdownTimeLeft % 60;
            document.getElementById('countdown').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // 残り時間に応じてステータスメッセージを更新
            if (currentMode === MODE.RECORDING) {
                if (countdownTimeLeft > RECORDING_START_TIME) {
                    // 録画開始前
                    const remainingSecondsToRecord = countdownTimeLeft - RECORDING_START_TIME;
                    const remainingMinutesToRecord = Math.ceil(remainingSecondsToRecord / 60);
                    
                    // デバッグ用の短い時間では秒単位で表示
                    if (TOTAL_COUNTDOWN_TIME === DEBUG_TOTAL_TIME) {
                        statusText.textContent = `Mode vidéo: Enregistrement dans ${remainingSecondsToRecord} seconde(s)`;
                    } else {
                        statusText.textContent = `Mode vidéo: Enregistrement dans ${remainingMinutesToRecord} minute(s)`;
                    }
                } else {
                    // 録画中
                    statusText.textContent = 'Mode vidéo: Enregistrement en cours !';
                }
            }
        }

        // 録画開始通知を表示する関数
        function showRecordingNotification() {
            // 既存の通知があれば削除
            hideRecordingNotification();
            
            // 新しい通知要素を作成
            recordingNotification = document.createElement('div');
            recordingNotification.style.position = 'fixed';
            recordingNotification.style.top = '20px';
            recordingNotification.style.left = '50%';
            recordingNotification.style.transform = 'translateX(-50%)';
            recordingNotification.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
            recordingNotification.style.color = 'white';
            recordingNotification.style.padding = '10px 20px';
            recordingNotification.style.borderRadius = '5px';
            recordingNotification.style.fontSize = '18px';
            recordingNotification.style.fontWeight = 'bold';
            recordingNotification.style.zIndex = '1000';
            recordingNotification.textContent = 'Enregistrement démarré !'; // フランス語で「録画開始！」
            
            // 点滅効果
            recordingNotification.style.animation = 'blink 1s infinite';
            const style = document.createElement('style');
            style.textContent = `
                @keyframes blink {
                    0% { opacity: 1; }
                    50% { opacity: 0.5; }
                    100% { opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            // ページに追加
            document.body.appendChild(recordingNotification);
        }
        
        // アプリのリセット
        function resetApp() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            if (camera) {
                camera.stop();
            }
            
            stopCountdown();
            
             // 録画関連の状態もリセット
            recordingStarted = false;
            hideRecordingNotification();

            currentMode = MODE.IDLE;
            statusText.textContent = 'Tap "1. Start \'Before\' Photo" to begin.';
            poseInfo.textContent = 'Tap "1. Start \'Before\' Photo" to begin.';
            progressFill.style.width = '0%';
    
            startBtn.textContent =   '1. Start "Before" Photo';
            previewBtn.disabled = true;
            //switchCameraBtn.disabled = true;
            //manualCaptureBtn.disabled = true;
            
            beforeCaptures.style.display = 'none';
            videoCapture.style.display = 'none';
            afterCaptures.style.display = 'none';
            
            stableStartTime = null;
            stablePosition = false;
            faceDetected = false;
            beforeCapturesCount = 0;
            afterCapturesCount = 0;
            beforeCapturesList = [];
            afterCapturesList = [];
            showFaceOutline = true; // 輪郭表示を有効に戻す
            // 青軸表示を元に戻す
            showAxis = true;
        }

        // 録画開始通知を非表示にする関数
        function hideRecordingNotification() {
            if (recordingNotification) {
                document.body.removeChild(recordingNotification);
                recordingNotification = null;
            }
        }
        
        // MediaPipe結果処理
        function onResults(results) {
            // キャンバスをクリア
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            
            // 入力画像を描画（ミラーリングして直感的な動きに）
            canvasCtx.scale(-1, 1);
            canvasCtx.translate(-outputCanvas.width, 0);
            canvasCtx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                faceDetected = true;
                
                // 顔のランドマークを描画（ミラーリング状態で描画） - showMeshフラグで条件分岐
                if (showMesh && currentMode !== MODE.RECORDING) {
                    for (const landmarks of results.multiFaceLandmarks) {
                        drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, 
                                    {color: '#C0C0C070', lineWidth: 1});
                        drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, 
                                    {color: '#FF3030', lineWidth: 2});
                        drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYEBROW, 
                                    {color: '#FF3030', lineWidth: 2});
                        drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE, 
                                    {color: '#30FF30', lineWidth: 2});
                        drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYEBROW, 
                                    {color: '#30FF30', lineWidth: 2});
                        drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL, 
                                    {color: '#E0E0E0', lineWidth: 2});
                        drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS, 
                                    {color: '#E0E0E0', lineWidth: 2});
                    }
                }
                
                // 顔の姿勢を計算
                calculateFacePose(results.multiFaceLandmarks[0]);
                
                // 3軸の表示条件を修正 - RECORDING モード以外で表示するように変更
                if (currentMode !== MODE.RECORDING && showAxis) {
                    drawPoseAxes(results.multiFaceLandmarks[0]);
                }
                
                // 姿勢情報を表示
                canvasCtx.restore(); // ミラーリングをリセット

                if (poseInfo) {
                    if (currentMode === MODE.RECORDING) {
                        // 録画モード中は姿勢情報を表示しない
                        poseInfo.textContent = '';
                    } else {
                        poseInfo.textContent = `Alignez votre visage avec le contour. Roulis: ${facePose.roll.toFixed(1)}°, Tangage: ${facePose.pitch.toFixed(1)}°, Lacet: ${facePose.yaw.toFixed(1)}°`;
                    }
                }

                // 姿勢が正面に近いかチェック
                checkFrontFacing();
            } else {
                canvasCtx.restore(); // ミラーリングをリセット
                faceDetected = false;
                stableStartTime = null;
                stablePosition = false;
                progressFill.style.width = '0%';
                 if (poseInfo && currentMode !== MODE.RECORDING) {
                    poseInfo.textContent = 'Visage non détecté';
                }
            }

            // 顔の輪郭ガイドを描画する条件を単純化
            // BEFORE, AFTER モードの場合に表示（キャプチャ瞬間以外）
            const shouldShowOutline = (currentMode === MODE.BEFORE || currentMode === MODE.AFTER) && !stablePosition;
   
            // 顔の輪郭ガイドを描画する条件をより明示的に
            if (currentMode === MODE.BEFORE || currentMode === MODE.AFTER) {
                // BEFORE または AFTER モードの場合のみ、かつキャプチャ中でない場合
                if (!stablePosition) {
                    drawFaceOutline();
                }
            }
        }

        // 追加の確認として、RECORDING モードに直接影響する
        // drawFaceOutline関数を修正
        function drawFaceOutline() {
            // 録画モード中は描画しない（追加の安全対策）
            if (currentMode === MODE.RECORDING) {
                console.log('録画モード中は輪郭を描画しない');
                return;
            }
            
            // キャンバスの中央座標
            const centerX = outputCanvas.width / 2;
            const centerY = outputCanvas.height / 2;
            
            // 楕円のサイズ
            const outlineWidth = outputCanvas.width * 0.3; // 画面幅の30%
            const outlineHeight = outputCanvas.height * 0.8; // 画面高さの80%
            
            // 楕円を描画
            canvasCtx.beginPath();
            canvasCtx.ellipse(
                centerX, 
                centerY, 
                outlineWidth / 2, 
                outlineHeight / 2, 
                0, 
                0, 
                2 * Math.PI
            );
            canvasCtx.strokeStyle = 'rgba(255, 105, 180, 0.8)'; // ピンク色（透明度80%）
            canvasCtx.lineWidth = 3;
            canvasCtx.stroke();
            
            console.log('輪郭ガイドを描画（モード:', currentMode, '）');
        }

        
        // 顔の姿勢計算
        function calculateFacePose(landmarks) {
            // 特徴点の取得
            const nose = landmarks[1];
            const leftEye = landmarks[33];
            const rightEye = landmarks[263];
            const leftMouth = landmarks[61];
            const rightMouth = landmarks[291];
            
            // ロール（Z軸回転）- 目の傾き - ミラーリング対応
            const eyeDiffY = rightEye.y - leftEye.y; // 左右を入れ替え
            const eyeDiffX = rightEye.x - leftEye.x; // 左右を入れ替え
            facePose.roll = -Math.atan2(eyeDiffY, eyeDiffX) * 180 / Math.PI; // 符号を反転
            
            // ピッチ（X軸回転）- 縦方向の傾き
            const mouthCenter = {
                y: (leftMouth.y + rightMouth.y) / 2
            };
            const eyeCenter = {
                y: (leftEye.y + rightEye.y) / 2
            };
            const eyeToMouthDist = mouthCenter.y - eyeCenter.y;
            // 基準値を調整して正面時にゼロに近くなるように
            facePose.pitch = (eyeToMouthDist - 0.22) * 150;
            
            // ヨー（Y軸回転）- 横方向の向き - ミラーリング対応
            const eyeMidPoint = {
                x: (leftEye.x + rightEye.x) / 2
            };
            const noseMidOffset = eyeMidPoint.x - nose.x; // ミラーリングに合わせて方向反転
            // ミラーリングに合わせて符号を調整
            facePose.yaw = noseMidOffset * 500;
        }
        
        // 3軸表示（現在は青軸のみ表示、他はコメントアウト）
        function drawPoseAxes(landmarks) {
            // 軸を表示しない場合は早期リターン
            if (!showAxis) return;

            // 鏡像表示に対応するための変換
            canvasCtx.scale(-1, 1);
            canvasCtx.translate(-outputCanvas.width, 0);
            
            const nose = landmarks[1];
            const scale = 0.2; // 軸の長さを2倍に変更 (元は0.1)
            
            // 座標軸の描画（鼻から伸びる3軸）
            // ミラーリング時の座標に変換
            const noseX = (1 - nose.x) * outputCanvas.width;
            const noseY = nose.y * outputCanvas.height;
            const noseZ = nose.z * outputCanvas.width;
            
            // X軸（赤）- ロール（向きを反転）- 現在は非表示
            /*
            const rotationZ = facePose.roll * Math.PI / 180;
            const xAxisX = noseX - Math.cos(rotationZ) * scale * outputCanvas.width;
            const xAxisY = noseY - Math.sin(rotationZ) * scale * outputCanvas.width;
            canvasCtx.beginPath();
            canvasCtx.moveTo(noseX, noseY);
            canvasCtx.lineTo(xAxisX, xAxisY);
            canvasCtx.strokeStyle = 'red';
            canvasCtx.lineWidth = 12;
            canvasCtx.stroke();
            */
            
            // Y軸（緑）- ピッチ（上方向）- 現在は非表示
            /*
            const yAxisY = noseY - Math.cos(facePose.pitch * Math.PI / 180) * scale * 1.2 * outputCanvas.height;
            const yAxisZ = noseZ - Math.sin(facePose.pitch * Math.PI / 180) * scale * 1.2 * outputCanvas.height;
            canvasCtx.beginPath();
            canvasCtx.moveTo(noseX, noseY);
            canvasCtx.lineTo(noseX, yAxisY);
            canvasCtx.strokeStyle = 'green';
            canvasCtx.lineWidth = 12;
            canvasCtx.stroke();
            */
            
            // Z軸（青）- ヨー（180度回転）- 現在のみ表示
            const zAxisX = noseX + Math.sin(facePose.yaw * Math.PI / 180) * scale * outputCanvas.width; // 向きを180度反転
            const zAxisZ = noseZ + Math.cos(facePose.yaw * Math.PI / 180) * scale * outputCanvas.width; // 向きを180度反転
            
            // 円柱の描画（Z軸）
            const cylinderWidth = 12; // 円柱の幅
            const angle = Math.atan2(0, zAxisX - noseX); // 水平角度
            
            // グラデーションで円柱効果を作成
            const gradient = canvasCtx.createLinearGradient(noseX, noseY, zAxisX, noseY);
            gradient.addColorStop(0, 'rgba(0, 0, 255, 1)'); // 濃い青（始点）
            gradient.addColorStop(1, 'rgba(100, 100, 255, 1)'); // 明るい青（終点）
            
            // 円柱の本体
            canvasCtx.beginPath();
            canvasCtx.moveTo(noseX, noseY - cylinderWidth/2);
            canvasCtx.lineTo(zAxisX, noseY - cylinderWidth/2);
            canvasCtx.lineTo(zAxisX, noseY + cylinderWidth/2);
            canvasCtx.lineTo(noseX, noseY + cylinderWidth/2);
            canvasCtx.closePath();
            canvasCtx.fillStyle = gradient;
            canvasCtx.fill();
            
            // 終点の円
            canvasCtx.beginPath();
            canvasCtx.arc(zAxisX, noseY, cylinderWidth/2, 0, Math.PI * 2);
            canvasCtx.fillStyle = 'rgba(100, 100, 255, 1)';
            canvasCtx.fill();
            
            // 始点の円
            canvasCtx.beginPath();
            canvasCtx.arc(noseX, noseY, cylinderWidth/2, 0, Math.PI * 2);
            canvasCtx.fillStyle = 'rgba(0, 0, 255, 1)';
            canvasCtx.fill();
        }
        
        // 正面向きチェック
        function checkFrontFacing() {
            console.log('現在のモード:', currentMode);
            // モードに基づいて処理をスキップする条件
            const skipCheck = 
                currentMode === MODE.RECORDING || 
                currentMode === MODE.BEFORE_COMPLETED || 
                currentMode === MODE.AFTER_COMPLETED || 
                currentMode === MODE.COMPLETED;
            
            if (currentMode === MODE.AFTER) {
                console.log('現在アフターモードです。輪郭表示が必要です'); // デバッグ用
            }

            if (skipCheck) {
                // 非アクティブモードではプログレスバーをクリア
                if (progressFill.style.width !== '0%') {
                    progressFill.style.width = '0%';
                }
                return;
            }
            
            // 顔が検出されていない場合もプログレスバーをクリア
            if (!faceDetected) {
                if (stableStartTime !== null || progressFill.style.width !== '0%') {
                    stableStartTime = null;
                    stablePosition = false;
                    progressFill.style.width = '0%';
                }
                return;
            }
            
            // 現在のしきい値を取得（parseFloatを使用）
            const rollThresholdVal = parseFloat(rollThreshold.value);
            const pitchThresholdVal = parseFloat(pitchThreshold.value);
            const yawThresholdVal = parseFloat(yawThreshold.value);
            const stabilityTimeVal = parseFloat(stabilityTime.value);
            
            // 姿勢が正面条件を満たしているか確認
            const isFrontFacing = 
                Math.abs(facePose.roll) < rollThresholdVal &&
                Math.abs(facePose.pitch) < pitchThresholdVal &&
                Math.abs(facePose.yaw) < yawThresholdVal;
            
            // 条件に基づいてプログレスバーを更新
            if (isFrontFacing) {
                if (stableStartTime === null) {
                    stableStartTime = Date.now();
                    console.log('姿勢が安定: 計測開始');
                }
                
                const elapsedTime = (Date.now() - stableStartTime) / 1000;
                const progressPercent = (elapsedTime / stabilityTimeVal) * 100;
                const cappedProgress = Math.min(progressPercent, 100);
                
                progressFill.style.width = `${cappedProgress}%`;
                
                // 十分な時間、姿勢が安定していたらキャプチャ
                if (elapsedTime >= stabilityTimeVal && !stablePosition) {
                    console.log('安定時間達成: キャプチャ実行');
                    stablePosition = true;
                    
                    // 現在のモードに応じたキャプチャ処理
                    if (currentMode === MODE.BEFORE && beforeCapturesCount < 5) {
                        captureBeforeImage();
                    } else if (currentMode === MODE.AFTER && afterCapturesCount < 5) {
                        captureAfterImage();
                    }
                }
            } else {
                // 姿勢が条件を満たさない場合はリセット
                if (stableStartTime !== null || progressFill.style.width !== '0%') {
                    stableStartTime = null;
                    stablePosition = false;
                    progressFill.style.width = '0%';
                    console.log('姿勢が不安定: リセット');
                }
            }
        }
        // ビフォー画像の撮影
        function captureBeforeImage() {
            console.log('ビフォー画像キャプチャ開始');
            // 姿勢が安定した状態をリセット
            stablePosition = false;
            // 一時的に輪郭表示を無効にする
            showFaceOutline = false;
            
            // 映像のみを一時的なキャンバスにコピー
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = outputCanvas.width;
            tempCanvas.height = outputCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 現在の映像のみを描画（ミラーリング状態を再現）
            tempCtx.save();
            tempCtx.scale(-1, 1);
            tempCtx.translate(-tempCanvas.width, 0);
            tempCtx.drawImage(inputVideo, 0, 0, tempCanvas.width, tempCanvas.height);
            tempCtx.restore();
            
            // この一時キャンバスから画像を取得
            const imageData = tempCanvas.toDataURL('image/jpeg');
            
            // 撮影情報を保存
            const captureInfo = {
                image: imageData,
                pitch: facePose.pitch,
                yaw: facePose.yaw,
                timestamp: new Date().toLocaleTimeString(),
                deviation: Math.abs(facePose.pitch) + Math.abs(facePose.yaw)
            };
            
            beforeCapturesList.push(captureInfo);
            beforeCapturesCount++;
            
            if (beforeCapturesCount < 5) {
                // 次の撮影に進む
                statusText.textContent = `ビフォー撮影モード: 正面を向いてください (${beforeCapturesCount + 1}/5)`;
                // 明示的にプログレスバーをリセット
                progressFill.style.width = '0%';
                // 安定時間を空けるために少し待機
                setTimeout(() => {
                    stableStartTime = null;
                    showFaceOutline = true; // 輪郭表示を再度有効化
                }, 500);
            } else {
                console.log('ビフォー撮影完了');
                // 明示的にプログレスバーとタイマーをリセット
                progressFill.style.width = '0%';
                stableStartTime = null;
                stablePosition = false;
                showFaceOutline = true;
                // 5枚撮影完了 - 最も良い画像のみ表示
                const bestCapture = findBestCapture(beforeCapturesList);
                
                // グリッドをクリアして最良の1枚だけを表示
                beforeGrid.innerHTML = '';
                addCaptureToGrid(bestCapture, beforeGrid, 1);
                beforeCaptures.style.display = 'block';
                
                // ビフォーモード完了
                currentMode = MODE.BEFORE_COMPLETED;
                statusText.textContent = 'Let\'s start the challenge! Tap "2. Start 5-Min Challenge".';
                previewBtn.disabled = false;
            }
        }

        // アフター画像の撮影
        function captureAfterImage() {
            console.log('アフター画像キャプチャ開始');
            // 姿勢が安定した状態をリセット
            stablePosition = false;
            
            // 映像のみを一時的なキャンバスにコピー
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = outputCanvas.width;
            tempCanvas.height = outputCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 現在の映像のみを描画（ミラーリング状態を再現）
            tempCtx.save();
            tempCtx.scale(-1, 1);
            tempCtx.translate(-tempCanvas.width, 0);
            tempCtx.drawImage(inputVideo, 0, 0, tempCanvas.width, tempCanvas.height);
            tempCtx.restore();
            
            // この一時キャンバスから画像を取得
            const imageData = tempCanvas.toDataURL('image/jpeg');
            
            // 撮影情報を保存
            const captureInfo = {
                image: imageData,
                pitch: facePose.pitch,
                yaw: facePose.yaw,
                timestamp: new Date().toLocaleTimeString(),
                deviation: Math.abs(facePose.pitch) + Math.abs(facePose.yaw)
            };
            
            afterCapturesList.push(captureInfo);
            afterCapturesCount++;
            
            if (afterCapturesCount < 5) {
                // 次の撮影に進む
                statusText.textContent = `Mode photo "après": Ajustez votre visage face à la caméra `;
                // 明示的にプログレスバーをリセット
                progressFill.style.width = '0%';
                // 安定時間を空けるために少し待機
                setTimeout(() => {
                    stableStartTime = null;
                    stablePosition = false; // 明示的に false に設定
                    // 青軸表示を保持
                    showAxis = true;
                    console.log('次のアフターキャプチャの準備完了');
                }, 500);
            } else {
                console.log('アフター撮影完了');
                // 5枚撮影完了
                statusText.textContent = 'Photos "après" terminées！';
                // 輪郭表示を再び有効にする
                showFaceOutline = true;

                // プログレスバーを明示的にリセット
                progressFill.style.width = '0%';
                stableStartTime = null;
                stablePosition = false;

                // 遅延をかけてから処理を続行
                setTimeout(() => {
                    // 最も良い画像のみ表示
                    const bestCapture = findBestCapture(afterCapturesList);
                    
                    // グリッドをクリアして最良の1枚だけを表示
                    afterGrid.innerHTML = '';
                    addCaptureToGrid(bestCapture, afterGrid, 1);
                    afterCaptures.style.display = 'block';
                    
                    // すべて完了
                    currentMode = MODE.COMPLETED;
                    statusText.textContent = 'Terminé ! Vous pouvez comparer les photos avant/après';
                    startBtn.textContent = 'Recommencer';
                    
                    // 施術部位選択ダイアログを表示（少し遅延をかける）
                    setTimeout(() => {
                        // この時点で施術部位選択ダイアログを表示
                        document.getElementById('side-dialog-image').src = bestCapture.image;
                        document.getElementById('side-dialog-overlay').style.display = 'block';
                        document.getElementById('side-dialog').style.display = 'block';
                    }, 500);
                }, 1000);
            }
        }

        // 最も良い撮影を見つける
        function findBestCapture(captures) {
            // 偏差が最小のものを見つける
            let bestIndex = 0;
            let minDeviation = captures[0].deviation;
            
            for (let i = 1; i < captures.length; i++) {
                if (captures[i].deviation < minDeviation) {
                    minDeviation = captures[i].deviation;
                    bestIndex = i;
                }
            }
            
            return captures[bestIndex];
        }

        // 撮影画像をグリッドに追加
        function addCaptureToGrid(captureInfo, grid, index) {
            const captureItem = document.createElement('div');
            captureItem.className = 'capture-item';
            captureItem.dataset.index = index - 1; // 0ベースインデックス
            
            const img = document.createElement('img');
            img.className = 'capture-image';
            img.src = captureInfo.image;
            img.alt = `撮影 ${index}`;
            
            const info = document.createElement('div');
            info.className = 'capture-info';
            info.textContent = `P: ${captureInfo.pitch.toFixed(1)}°, Y: ${captureInfo.yaw.toFixed(1)}°`;
            
            captureItem.appendChild(img);
            captureItem.appendChild(info);
            grid.appendChild(captureItem);
        }

        // 最も良い撮影を見つけてマークする
        function findAndMarkBestCapture(captures, grid) {
            // 偏差が最小のものを見つける
            let bestIndex = 0;
            let minDeviation = captures[0].deviation;
            
            for (let i = 1; i < captures.length; i++) {
                if (captures[i].deviation < minDeviation) {
                    minDeviation = captures[i].deviation;
                    bestIndex = i;
                }
            }
            
            // 最も良い撮影に赤枠を付ける
            const items = grid.querySelectorAll('.capture-item');
            items[bestIndex].classList.add('best');
        }

        // 手動キャプチャ
        function manualCapture() {
            if (currentMode === MODE.BEFORE && beforeCapturesCount < 5) {
                captureBeforeImage();
            } else if (currentMode === MODE.AFTER && afterCapturesCount < 5) {
                captureAfterImage();
            }
        }

        // 録画開始
        function startRecording() {
            recordedChunks = [];
            
            // コーデック優先順位をMP4優先に変更
            let options;
            try {
                // まずMP4（iPhoneに対応）を試す
                options = { mimeType: 'video/mp4' };
                mediaRecorder = new MediaRecorder(stream, options);
            } catch (e1) {
                try {
                    // 次にwebm+vp8を試す
                    options = { mimeType: 'video/webm;codecs=vp8,opus' };
                    mediaRecorder = new MediaRecorder(stream, options);
                } catch (e2) {
                    try {
                        // 最後にコーデック指定なしのwebmを試す
                        options = { mimeType: 'video/webm' };
                        mediaRecorder = new MediaRecorder(stream, options);
                    } catch (e3) {
                        console.error('どの録画フォーマットもサポートされていません:', e3);
                        statusText.textContent = '録画機能がサポートされていません';
                        return;
                    }
                }
            }
            
            mediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = function() {
                // MIMEタイプを取得
                const mimeType = mediaRecorder.mimeType;
                const isMP4 = mimeType.includes('mp4');
                
                // 適切な拡張子を選択
                const fileExtension = isMP4 ? 'mp4' : 'webm';
                
                const blob = new Blob(recordedChunks, { type: mimeType });
                const url = URL.createObjectURL(blob);
                recordedVideo.src = url;
                downloadLink.href = url;
                videoCapture.style.display = 'block';
                
                // タイムスタンプを追加してファイル名をカスタマイズ（拡張子を動的に変更）
                const now = new Date();
                const timestamp = now.toISOString().replace(/[:.]/g, '-').substring(0, 19);
                downloadLink.download = `recorded-video-${timestamp}.${fileExtension}`;
            };
            
            mediaRecorder.start(1000); // 1秒ごとにデータを取得
        }

        // 録画停止
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                recordingStarted = false;
                hideRecordingNotification();
            }
        }

        // メールダイアログを表示
        function showEmailDialog() {
            document.getElementById('email-overlay').style.display = 'block';
            document.getElementById('email-dialog').style.display = 'block';
            
            // 現在のメールアドレスを入力欄にセット
            if (userEmail) {
                document.getElementById('email-input').value = userEmail;
            }
        }

        // メールアドレスを保存
        function saveEmail() {
            const emailInput = document.getElementById('email-input');
            const email = emailInput.value.trim();
            const privacyAgree = document.getElementById('privacy-agree').checked;
            
            if (!privacyAgree) {
                alert('プライバシーポリシーへの同意が必要です');
                return;
            }
            
            if (email && validateEmail(email)) {
                userEmail = email;
                document.getElementById('email-overlay').style.display = 'none';
                document.getElementById('email-dialog').style.display = 'none';
                
                // メールアドレスを表示
                const emailDisplay = document.getElementById('email-display');
                emailDisplay.textContent = `メール: ${email}`;
                emailDisplay.style.display = 'block';
            } else {
                alert('Veuillez entrer une adresse e-mail valide');
            }
        }

        // メールアドレスの簡易バリデーション
        function validateEmail(email) {
            const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return re.test(email);
        }

        // 施術部位選択ダイアログを表示
        function showSideDialog(imageUrl) {
            document.getElementById('side-dialog-image').src = imageUrl;
            document.getElementById('side-dialog-overlay').style.display = 'block';
            document.getElementById('side-dialog').style.display = 'block';
        }

        // 施術部位選択ダイアログを閉じる
        function closeSideDialog() {
            document.getElementById('side-dialog-overlay').style.display = 'none';
            document.getElementById('side-dialog').style.display = 'none';
        }

        // formData未定義エラーの修正
        // 施術部位選択後にAPI送信を行う関数の修正
        function saveTreatedSide(side) {
            treatedSide = side;
            console.log(`施術された側: ${side}`);
            
            // ダイアログを閉じる
            document.getElementById('side-dialog-overlay').style.display = 'none';
            document.getElementById('side-dialog').style.display = 'none';
            
            // ビフォー画像とアフター画像の取得
            const beforeBestCapture = findBestCapture(beforeCapturesList);
            const afterBestCapture = findBestCapture(afterCapturesList);
            
            // 動画ブロブの取得
            let videoBlob = null;
            if (recordedChunks.length > 0) {
                const mimeType = mediaRecorder ? mediaRecorder.mimeType : 'video/webm';
                videoBlob = new Blob(recordedChunks, { type: mimeType });
            }
            
            // APIにデータを送信 - sendDataToAPI関数内でformDataを作成するので、
            // ここではformDataを直接操作しない
            sendDataToAPI(beforeBestCapture.image, afterBestCapture.image, videoBlob).then(success => {
                if (success) {
                    // 成功時の通知は sendDataToAPI 内で処理
                    console.log('データ送信成功');
                }
            });
        }

        // ビフォー画像に最も近いアフター画像を選択するロジックに変更

        // 最も姿勢が近いアフター画像を見つける関数
        function findSimilarToBeforeCapture(afterCapturesList) {
            // ビフォーの最良キャプチャを取得（既存のロジックで選択されたもの）
            const bestBeforeCapture = findBestCapture(beforeCapturesList);
            
            if (!bestBeforeCapture || afterCapturesList.length === 0) {
                // データが不足している場合は既存の方法で選択
                return findBestCapture(afterCapturesList);
            }
            
            // ビフォー画像の姿勢（ピッチとヨー）
            const beforePitch = bestBeforeCapture.pitch;
            const beforeYaw = bestBeforeCapture.yaw;
            
            // 各アフター画像について、ビフォー画像との姿勢の違いを計算
            let bestIndex = 0;
            let minDifference = Number.MAX_VALUE;
            
            for (let i = 0; i < afterCapturesList.length; i++) {
                const afterCapture = afterCapturesList[i];
                // ピッチとヨーの差の二乗和の平方根（ユークリッド距離）を計算
                const pitchDiff = afterCapture.pitch - beforePitch;
                const yawDiff = afterCapture.yaw - beforeYaw;
                const difference = Math.sqrt(pitchDiff * pitchDiff + yawDiff * yawDiff);
                
                console.log(`アフターキャプチャ ${i+1} の姿勢差: ${difference.toFixed(2)}°`);
                
                // より小さい差を持つキャプチャを見つけたら更新
                if (difference < minDifference) {
                    minDifference = difference;
                    bestIndex = i;
                }
            }
            
            console.log(`ビフォーに最も近いアフター画像はインデックス ${bestIndex+1} です（姿勢差: ${minDifference.toFixed(2)}°）`);
            
            return afterCapturesList[bestIndex];
        }

        // captureAfterImage関数のアフター撮影完了部分を修正
        // 既存の関数を保存
        const originalCaptureAfterImage = window.captureAfterImage;

        // 関数を上書き
        window.captureAfterImage = function() {
            // 元の関数がない場合（すでに上書きされている可能性）
            if (typeof originalCaptureAfterImage !== 'function') {
                console.error('元のcaptureAfterImage関数が見つかりません');
                return;
            }
            
            console.log('アフター画像キャプチャ開始');
            // 姿勢が安定した状態をリセット
            stablePosition = false;
            
            // 映像のみを一時的なキャンバスにコピー（既存コード）
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = outputCanvas.width;
            tempCanvas.height = outputCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 現在の映像のみを描画（ミラーリング状態を再現）
            tempCtx.save();
            tempCtx.scale(-1, 1);
            tempCtx.translate(-tempCanvas.width, 0);
            tempCtx.drawImage(inputVideo, 0, 0, tempCanvas.width, tempCanvas.height);
            tempCtx.restore();
            
            // この一時キャンバスから画像を取得
            const imageData = tempCanvas.toDataURL('image/jpeg');
            
            // 撮影情報を保存
            const captureInfo = {
                image: imageData,
                pitch: facePose.pitch,
                yaw: facePose.yaw,
                timestamp: new Date().toLocaleTimeString(),
                deviation: Math.abs(facePose.pitch) + Math.abs(facePose.yaw)
            };
            
            afterCapturesList.push(captureInfo);
            afterCapturesCount++;
            
            if (afterCapturesCount < 5) {
                // 次の撮影に進む（既存の処理）
                statusText.textContent = `Mode photo "après": Ajustez votre visage face à la caméra (${afterCapturesCount + 1}/5)`;
                // 明示的にプログレスバーをリセット
                progressFill.style.width = '0%';
                // 安定時間を空けるために少し待機
                setTimeout(() => {
                    stableStartTime = null;
                    console.log('次のアフターキャプチャの準備完了');
                }, 500);
            } else {
                console.log('アフター撮影完了');
                // 5枚撮影完了
                statusText.textContent = 'Photos "après" terminées !';

                // プログレスバーを明示的にリセット
                progressFill.style.width = '0%';
                stableStartTime = null;
                stablePosition = false;

                // 遅延をかけてから処理を続行
                setTimeout(() => {
                    // 【変更点】最もビフォーに近い画像を選択
                    const bestCapture = findSimilarToBeforeCapture(afterCapturesList);
                    
                    // グリッドをクリアして最良の1枚だけを表示
                    afterGrid.innerHTML = '';
                    addCaptureToGrid(bestCapture, afterGrid, 1);
                    afterCaptures.style.display = 'block';
                    
                    // すべて完了
                    currentMode = MODE.COMPLETED;
                    statusText.textContent = 'Terminé ! Vous pouvez comparer les photos avant/après';
                    startBtn.textContent = 'Recommencer';
                    
                    // 施術部位選択ダイアログを表示（少し遅延をかける）
                    setTimeout(() => {
                        // この時点で施術部位選択ダイアログを表示
                        document.getElementById('side-dialog-image').src = bestCapture.image;
                        document.getElementById('side-dialog-overlay').style.display = 'block';
                        document.getElementById('side-dialog').style.display = 'block';
                    }, 500);
                }, 1000);
            }
        };

        console.log('アフター画像選択ロジックを、ビフォー画像に近いものを選ぶように変更しました');

        // ウィンドウ読み込み時の初期化
        window.addEventListener('load', init);

         // イベントリスナーを初期設定
         document.addEventListener('DOMContentLoaded', function() {
            // 必要なイベントリスナーを追加
            document.getElementById('success-ok').addEventListener('click', function() {
                document.getElementById('success-overlay').style.display = 'none';
                document.getElementById('success-dialog').style.display = 'none';
            });
            
            document.getElementById('error-ok').addEventListener('click', function() {
                document.getElementById('error-overlay').style.display = 'none';
                document.getElementById('error-dialog').style.display = 'none';
            });
        });

        // シンプルにメッシュ表示と設定ボタンを非表示にする
        document.addEventListener('DOMContentLoaded', function() {
            // メッシュ表示ボタンを非表示
            const meshButton = document.getElementById('toggle-mesh-btn');
            if (meshButton) meshButton.style.display = 'none';
            
            // 設定表示ボタンを非表示
            const settingsButton = document.getElementById('toggle-settings-btn');
            if (settingsButton) settingsButton.style.display = 'none';
        });

        // iPad向けレイアウト最適化のための完全なスクリプト

        // 即時実行関数で変数スコープを適切に管理
        (function() {
            // CSS定義を変数に格納
            const ipadStyles = `
            <style>
                /* 全体のコンテナサイズ調整 */
                body {
                    overflow: auto;
                    padding: 0;
                    margin: 0;
                    height: 100%;
                    width: 100%;
                    position: fixed;
                    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                }
                
                .container {
                    max-width: 100%;
                    padding: 10px;
                    margin: 0 auto;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    height: 100vh;
                    box-sizing: border-box;
                    overflow-y: auto;
                    -webkit-overflow-scrolling: touch;
                }
                
                /* ビデオコンテナを画面に合わせる */
                .video-container {
                    position: relative;
                    width: 100%;
                    max-width: 80%;
                    height: 0;
                    padding-bottom: 60%; /* アスペクト比を維持 */
                    margin-bottom: 15px;
                    overflow: hidden;
                }
                
                #input-video {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                    border-radius: 8px;
                    background-color: #000;
                }
                
                #output-canvas {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    border-radius: 8px;
                    object-fit: cover;
                }
                
                /* カウントダウン表示を中央に配置 */
                .countdown-large {
                    font-size: 48px;
                    font-weight: bold;
                    color: white;
                    background-color: black;
                    padding: 10px 30px;
                    border-radius: 8px;
                    text-align: center;
                    margin-bottom: 15px;
                    width: 180px;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10;
                    position: absolute;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                }
                
                /* ステータスパネルの調整 */
                .status-panel {
                    width: 100%;
                    max-width: 80%;
                    background-color: #fff;
                    border-radius: 8px;
                    padding: 12px;
                    margin-bottom: 15px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                }
                
                .status-text {
                    font-size: 16px;
                    text-align: center;
                    margin-bottom: 8px;
                }
                
                .pose-info {
                    font-size: 14px;
                    text-align: center;
                    margin-bottom: 8px;
                }
                
                /* コントロールボタンの調整 */
                .controls {
                    display: flex;
                    gap: 8px;
                    margin-bottom: 15px;
                    flex-wrap: wrap;
                    justify-content: center;
                    width: 100%;
                    max-width: 80%;
                }
                
                button {
                    padding: 10px 15px;
                    border-radius: 8px;
                    border: none;
                    background-color: #0066cc;
                    color: white;
                    font-size: 15px;
                    cursor: pointer;
                    min-width: 120px;
                }
                
                /* ギャラリー表示の調整 */
                .gallery {
                    width: 100%;
                    max-width: 80%;
                    display: flex;
                    flex-direction: column;
                    gap: 15px;
                    margin-bottom: 20px;
                }
                
                .gallery-item {
                    background-color: #fff;
                    border-radius: 8px;
                    padding: 12px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                }
                
                .captures-grid {
                    display: block;
                    max-width: 100%;
                    margin: 0 auto;
                }
                
                .capture-item {
                    position: relative;
                    border: 2px solid #f44336;
                    border-radius: 4px;
                    padding: 5px;
                    margin: 0 auto;
                    max-width: 250px;
                }
                
                .capture-image {
                    width: 100%;
                    border-radius: 2px;
                    display: block;
                }
                
                /* ダイアログの調整 */
                .email-dialog, .side-dialog, .dialog {
                    max-width: 80%;
                    width: 350px;
                }
                
                /* オーバーレイの調整 */
                .overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.7);
                    z-index: 1000;
                }

                /* Emailの表示位置とサイズ調整 */
                .email-display {
                    background-color: rgba(240, 240, 240, 0.7);
                    padding: 3px 8px;
                    border-radius: 4px;
                    margin-top: 5px;
                    font-size: 12px;
                    position: fixed;
                    top: 5px;
                    right: 10%;
                    z-index: 1000;
                    cursor: pointer;
                    border: 1px solid #ddd;
                    max-width: 200px;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }
                
                /* 録画動画表示の調整 */
                .recorded-video {
                    width: 100%;
                    max-height: 300px;
                    border-radius: 4px;
                    display: block;
                    margin: 0 auto;
                }
                
                /* フォントサイズの全体的な調整 */
                h3 {
                    font-size: 18px;
                    margin-top: 5px;
                    margin-bottom: 10px;
                }
                
                /* iPadの縦向きでも横向きでも見やすいように */
                @media screen and (orientation: portrait) {
                    /* 縦向き時のスタイル */
                    .video-container {
                        padding-bottom: 75%; /* より縦長に */
                    }
                }
                
                @media screen and (orientation: landscape) {
                    /* 横向き時のスタイル */
                    .container {
                        flex-direction: row;
                        flex-wrap: wrap;
                        justify-content: center;
                        align-items: flex-start;
                    }
                    
                    .video-container {
                        width: 60%;
                        padding-bottom: 45%;
                    }
                    
                    .status-panel, .controls, .gallery {
                        width: 35%;
                        max-width: 35%;
                    }
                }
            </style>
            `;

            // 輪郭ガイドラインの調整関数（横幅を広げる）
            function adjustFaceOutline() {
                // drawFaceOutline関数を修正
                window.drawFaceOutline = function() {
                    // 録画モード中は描画しない
                    if (currentMode === MODE.RECORDING) {
                        console.log('録画モード中は輪郭を描画しない');
                        return;
                    }
                    
                    // キャンバスの中央座標
                    const centerX = outputCanvas.width / 2;
                    const centerY = outputCanvas.height / 2;
                    
                    // iPad向けに調整された楕円のサイズ
                    const screenMin = Math.min(outputCanvas.width, outputCanvas.height);
                    
                    // 楕円のサイズ - 横幅を広げる（50%に変更）、高さは縦長に（60%維持）
                    const outlineWidth = screenMin * 0.4; // 画面の50%に広げる（元は40%）
                    const outlineHeight = screenMin * 0.6; // 画面の60%維持
                    
                    // 楕円を描画
                    canvasCtx.beginPath();
                    canvasCtx.ellipse(
                        centerX, 
                        centerY, 
                        outlineWidth / 2, 
                        outlineHeight / 2, 
                        0, 
                        0, 
                        2 * Math.PI
                    );
                    canvasCtx.strokeStyle = 'rgba(255, 105, 180, 0.8)'; // ピンク色
                    canvasCtx.lineWidth = 3;
                    canvasCtx.stroke();
                    
                    console.log('輪郭ガイドを描画（モード:', currentMode, '）');
                };
            }

            // Tangageのオフセット調整
            function adjustTangageOffset() {
                if (typeof window.calculateFacePose === 'function') {
                    const originalCalculateFacePose = window.calculateFacePose;
                    window.calculateFacePose = function(landmarks) {
                        // 元の関数を呼び出す
                        originalCalculateFacePose(landmarks);
                        
                        // iPadではピッチ（タンガージュ）に+10度のオフセットを適用
                        facePose.pitch = facePose.pitch + 10;
                    };
                    console.log('Tangageのオフセット調整を適用しました');
                }
            }

            // ボタンを非表示にする関数
            function hideButtons() {
                // メッシュ表示ボタンを非表示
                const meshButton = document.getElementById('toggle-mesh-btn');
                if (meshButton) meshButton.style.display = 'none';
                
                // 設定表示ボタンを非表示
                const settingsButton = document.getElementById('toggle-settings-btn');
                if (settingsButton) settingsButton.style.display = 'none';
                
                console.log('メッシュ表示と設定ボタンを非表示にしました');
            }

            // ビデオとキャンバスのサイズ同期関数
            function syncVideoAndCanvas() {
                if (inputVideo && outputCanvas) {
                    // ビデオがロードされたらキャンバスのサイズを合わせる
                    outputCanvas.width = inputVideo.videoWidth || inputVideo.clientWidth;
                    outputCanvas.height = inputVideo.videoHeight || inputVideo.clientHeight;
                    
                    console.log(`キャンバスサイズを同期: ${outputCanvas.width}x${outputCanvas.height}`);
                }
            }

            // レイアウト最適化のための設定を追加する関数
            function optimizeLayoutForIPad() {
                // HTMLのhead要素にCSSを追加
                document.head.insertAdjacentHTML('beforeend', ipadStyles);
                
                // 輪郭ガイドライン調整
                adjustFaceOutline();
                
                // Tangageのオフセット調整
                adjustTangageOffset();
                
                // ボタンを非表示に
                hideButtons();
                
                // ビデオとキャンバスのサイズ同期を確保
                window.addEventListener('resize', syncVideoAndCanvas);
                
                // ビデオのロード時とカメラ開始時にサイズを同期
                if (inputVideo) {
                    inputVideo.addEventListener('loadedmetadata', syncVideoAndCanvas);
                }
                
                // 既存のカメラ開始関数を拡張
                if (typeof window.startCamera === 'function') {
                    const originalStartCamera = window.startCamera;
                    window.startCamera = async function() {
                        const success = await originalStartCamera();
                        if (success) {
                            // カメラ起動成功後、少し遅延させてサイズを同期
                            setTimeout(syncVideoAndCanvas, 500);
                        }
                        return success;
                    };
                }
                
                console.log('iPadレイアウト最適化が適用されました');
            }

            // DOM要素が読み込まれたか確認してから実行
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', optimizeLayoutForIPad);
            } else {
                // DOMがすでに読み込まれている場合は直接実行
                optimizeLayoutForIPad();
            }
        })();
    </script>
</body>
</html>